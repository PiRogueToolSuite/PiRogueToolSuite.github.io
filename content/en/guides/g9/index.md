---
title: Advanced guide - How to use Colander to analyze the network traffic of an app
weight: 90
toc: true
draft: false
---


This guide will walk you through a step-by-step procedure, focusing on the decryption and analysis of network traffic intercepted using the PiRogue tool.

# Objective
The primary objective of this guide is to provide a detailed walkthrough of the process involved in decrypting and analyzing network traffic from a mobile application intercepted with PiRogue. If you're interested in intercepting TLS traffic of a mobile app, consider checking out our guide on [using PTS for intercepting TLS traffic](/guides/g8/).

# Introduction
In the contemporary landscape of mobile applications, a clear understanding of network communication intricacies is essential for professionals in cybersecurity. This guide explores the functionalities of Colander, a tool designed for the decryption and analysis of network traffic from mobile applications. Throughout this tutorial, our aim is to provide insights into the dissection of network transmissions intercepted by the PiRogue. Mobile applications often conceal complex patterns within their network communications. Colander facilitates a detailed examination of this concealed realm.

This guide offers a roadmap for those exploring network traffic analysis. From transmission decryption to manual decoding and the formulation of detection rules, each section contributes to a practical understanding. Whether a seasoned analyst or an enthusiast, this journey aims to decipher the digital communication intricacies inherent in mobile applications using Colander. 

# Network traffic analysis in Colander
Colander implements a graphical interface dedicated to traffic decryption, decoding and analysis of each network transmission. The purpose of this interface is to display information related to the network traffic as well as information related to the execution of the analyzed application. More precisely, this interface shows what part of an application was in charge of each network transmission.

{{< img src="img/decrypted_traffic.png" alt="Example of decrypted network transmission" caption="Example of decrypted network transmission" class="d-block mx-auto shadow" >}}

The interface of each network transmission is composed of the following sections:
1. summary of the transmission listing:
    * the direction of the transmission, either inbound or outbound
    * the layer-7 protocol
    * the amount of data sent or received
    * the source and destination IP addresses (and their name resolution)
2. Exodus Privacy analysis of the stack trace listing:
    * the name of the detected SDK, nothing otherwise
    * the purposes of the detected SDK
3. list of detection rules matching on the current transmission
4. *geoip* information of the remote server listing:
    * the Community ID of the flow
    * the ASN and its block of IPs
    * the organization
    * the country
5. Android process information listing:
    * the timestamp of the termination of the transmission
    * the Android process name (usually the package name of the application)
    * the ID of the process
    * the ID of the thread
    * the ID of the socket
6. headers of the HTTP request, empty otherwise
7. stack trace indicating what part of the application was in charge of the corresponding socket operations
8. indicates if the transmitted data/payload has been encrypted before transmission or not
9. controls on the data/payload allowing to:
    * view the raw data (encoded in hex) or the decrypted data (if encrypted before transmission)
    * send to CyberChef the raw data (encoded in hex) or the decrypted data (if encrypted before transmission)
    * import manually decoded data/payload/content
10. decoded transmitted data


# On hurry?
You are on hurry but can't remember the different commands to run on your PiRogue? Here they are:
* Instrument the mobile device: `pirogue-intercept-gated -o output`
* Wait until it says `Waiting for data` and start the application to be analyzed
* Hit `Ctrl + C` when done with the app
* Upload the experiment to Colander: `pirogue-colander collect-experiment -c "<ID of your case>" output/`
* Upload an artifact to Colander: `pirogue-colander collect-artifact -c "<ID of your case>" <path of the file to be uploaded>`

# Procedure
## Import artifacts
The first step is to import the artifacts generated by the PiRogue into Colander. 

If it is the first time you are using PiRogue in combination with Colander, you have to link your PiRogue to your Colander account. To do so, in Colander, click on your username at the top-right of the interface and find the exact command you must execute on your PiRogue. 

This command looks like:

```bash
pirogue-colander config -u "<URL for your Colander server>" -k "<your API key>"
```

This command will configure the connector for Colander. 

If the command `pirogue-colander` is not found, install the package `pirogue-colander-connector` by running the following commands on your PiRogue:

```bash 
sudo apt update
sudo apt install -y pirogue-colander-connector
```

This will update the list of available packages and install the necessary tools to connect your PiRogue to Colander.

Once the Colander connector is configured, use the `pirogue-colander` command to upload all the files generated during the instrumentation and execution of the mobile app. The commands `pirogue-intercept-single` and `pirogue-intercept-gated` generate various files stored in the folder of your choice.

As a reminder, here is the typical content of the output folder:

```text
output/
|-- ad_ids.txt
|-- aes_info.json
|-- device.json
|-- experiment.json
|-- screen.mp4
|-- socket_trace.json
|-- sslkeylog.txt
`-- traffic.pcap
```

The command `pirogue-colander` uses the file `experiment.json` to determine the different files to be uploaded to Colander. In Colander, select or create the case you want to upload these artifacts into and click on *Collect / PiRogue experiment*. At the bottom of the PiRogue experiment creation form, you will find a command to be executed on your PiRogue.

This command looks like:
```bash
pirogue-colander collect-experiment -c "<ID of your case>" <path of the folder containing your experiment>
```

If you want to upload the APK or XAPK file corresponding you have used to install the app, specify its path in the `-t` parameter:
```bash
pirogue-colander collect-experiment -c "<ID of your case>" -t <path to the APK or XAPK file> <path of the folder containing your experiment>
```

The command `pirogue-colander collect-experiment` will automatically upload all the files to Colander and create a new PiRogue experiment with the name you provided when asked.

As an example, if the folder containing generated files is located at `my_experiment/output` and the APK at `my_experiment/my_app.apk`, the command to run on the PiRogue looks like:

```bash
pirogue-colander collect-experiment -c "<ID of your case>" -t my_experiment/my_app.apk my_experiment/output
```

This command will ask for the name of the experiment and, if you specified an (X)APK file, it will ask you to choose a type for this artifact, select `Android sample`. After completion, go back in Colander, in the *Collect* workspace, select *PiRogue experiment* and check the details of the newly created one.

If you want to upload other artifacts stored on your PiRogue, use the command:

```bash
pirogue-colander collect-artifact -c "<ID of your case>" <path of the file to be uploaded>
```

You can find this command listed in Colander *Collect / Artifact* at the bottom of the artifact creation form.

{{< img src="img/experiment_graph.png" alt="Graph representation of a PiRogue experiment uploaded to Colander" caption="Graph representation of a PiRogue experiment uploaded to Colander" class="d-block mx-auto shadow" >}}


## Decrypt the network traffic
In Colander, open the details of your newly created PiRogue experiment and click on the button *Decrypt*. This will start the automatic traffic decryption in background, this could take a few minutes depending on the amount of traffic. 

Colander will be using the PCAP file `traffic.pcap` and the file `sslkeylog.txt` to decrypt the network traffic. Once decrypted, Colander will do the automatic enrichment. First, based on the [Community ID](https://github.com/corelight/community-id-spec) and time correlation, it will attach to each network flow the corresponding stack trace read from the file `socket_trace.json`. Each stack trace is then analyzed using [Exodus Privacy](https://exodus-privacy.eu.org/) detection rules to detect the SDK potentially involved in the transmission. Then, by comparing the raw payloads read from the decrypted traffic and the `in` and `out` payloads read from the file `aes_info.json` containing all cryptographic operations (not only AES), Colander will attach the corresponding cleartext. The purpose here is to decrypt payloads that were encrypted before being sent over TLS. Finally, ElasticSearch will automatically attach to each network flow the corresponding *geoip* information such as the country and the organization of the remote server.

After few minutes, refresh the page listing details of your experiment, you should see the decrypted traffic. 

## Decode payloads
The next step is to go through all network transmissions and manually decode the data/payload/content that has not been automatically decoded. To make easier for you, Colander can *send* the raw data (encoded in hex) or the decrypted data (if encrypted before transmission) to CyberChef. By default, the data is encoded in hexadecimal.

Write your recipe and once you are happy with its result, copy it, go back in Colander, click on *Import decoded content*, paste the output of your recipe and click on *Save*. Keep in mind that the detection rules will be applied on the decoded content your imported.

In some cases, Colander is not capable of identifying payloads that have been encrypted before been transmitted. If you encounter a payload you are not able to decode or you suspect it is encrypted, check the content of the file `aes_info.json` you uploaded at the first step of this guide. 

## Write detection rules
Once you have decoded all the transmissions, it is time for you to write your Yara detection rules. To do so, in *Collect / Detection rules* create a new Yara rule. You can declare as many rules as you want in the *Content* section. All the Yara rules you have added to your case will be applied on:
* the URL/URI
* the HTTP headers
* the HTTP decoded payload

As an example, here follows are 2 simple rules detecting the model and the brand of the mobile device:

```yara
rule device_model
{
  strings:
    $s = "SM-G965F" nocase
 condition:
    $s
}

rule device_brand
{
  strings:
    $s = "samsung" nocase
 condition:
    $s
}
```

Once you are happy if your detection rules, in the details of your PiRogue experiment, click on *Detect*. It will automatically apply all your rules. 

Please note you have to reapply your detection rules each time you modify them. Changes on the detection rules are not automatically taken into account.

## Generate the report
When comes the time to generate the detection report, in the details of your PiRogue experiment, click on *View report*. It will open in another tab and you can use the *print* functionality of your web browser to save it as PDF.

This report contains:
* all artifacts such as PCAP file containing traffic data or screen recording and their digital signatures
* the definition of the detection rules and the detection summary
* the list of all transmissions listing the source and destination host, IP address and organization, the technical part of the application that has been handling the given data transmission (internal application code or 3rd-party SDKs)
* the identification and classification of the transmitted data such as advertising ID, location data etc.
* when applicable, the inferred purpose (such as analytics or advertisement) of the data collection using [Exodus Privacy](https://exodus-privacy.eu.org/) tracker classification to identify the recipient company

Colander analysis and detection accuracy can be assessed by opening the PCAP file and the SSL keylog file in Wireshark and manually verifying each data transmission.
